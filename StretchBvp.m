function sol = StretchBvp(sigma,rho,init_guess,corneal_r,corneal_theta,IOP,C,zeta,psi,D,EB,bvp_tolerance)
% StretchBvp Solve the elastic boundary value problem for a thin shell.

	% Unpack sigma(epsilon), the first entry of sigma.
	sigma_epsilon = sigma(1);

	% Precompute required derivatives.
	drho_dsigma = gradient(rho,sigma);
	dzeta_dsigma = gradient(zeta,sigma);
	dpsi_dsigma = gradient(psi,sigma);

	% Create a scattered interpolant object so that the bvp solver can
	% evaluate material properties at its computational mesh efficiently. 6
	% functions will need interpolating.
	sample_points = {sigma, 1:6};
	F = griddedInterpolant(sample_points, [rho; drho_dsigma; zeta; dzeta_dsigma; psi; dpsi_dsigma]');
	F.Method = 'spline';

	% Call bvp4c.
	options = bvpset('RelTol',bvp_tolerance,'AbsTol',bvp_tolerance,'Stats','off',...
                 'NMax',10000,'Vectorized','on');
	sol = bvp4c(@bvpRHS,@bvpBC,init_guess,options);

	% Ensure that the solution is evaluated at the points sigma, not just at
	% the computational mesh used by bvp4c.
	sol = deval(sol,sigma);

% ----------------
% Nested functions
% ----------------

function rhs = bvpRHS(x,y)
% bvpRHS Compute the rhs of the bvp as required by bvp4c.
% 
% 	rhs = bvpRHS(x,y) computes the rhs of the bvp evaluated at the points x,
% 	which are the points of the computational mesh generated by the solver,
% 	and are analogous to sigma. y contains the dependent variables.
	
	% Extract the dependent variables at the points in x.
	kappa = y(1,:);
    alpha_s = y(2,:);
    r = y(3,:);
    theta = y(4,:);
    Q = y(5,:);

    % Interpolate the material properties at x.
    interpolated_funcs = F({x, 1:6})';
    rhoI = interpolated_funcs(1,:);
    drho_dsigmaI = interpolated_funcs(2,:);
    zetaI = interpolated_funcs(3,:);
    dzeta_dsigmaI = interpolated_funcs(4,:);
    psiI = interpolated_funcs(5,:);
    dpsi_dsigmaI = interpolated_funcs(6,:);

    % Compute the elastic stretch in the phi direction, alpha_phi.
    alpha_phi = r ./ rhoI;

    % Compute the invariant (I4) and deformations (F_s and F_phi).
    I4 = alpha_s.^2 .* sin(psiI).^2 + alpha_phi.^2 .* cos(psiI).^2;
    F_s = C * (alpha_s ./ alpha_phi - 1./(alpha_s.^3 .* alpha_phi.^3)) + D * (I4 - 1) .* alpha_s .* sin(psiI).^2 ./ alpha_phi; 
    F_phi = C * (alpha_phi ./ alpha_s - 1./(alpha_s.^3 .* alpha_phi.^3)) + D * (I4 - 1) .* alpha_phi .* cos(psiI).^2 ./ alpha_s;

    % Analytically compute further derivatives.
    dF_s_dalpha_phi = C * (3 ./ (alpha_s.^3 .* alpha_phi.^4) - alpha_s ./ alpha_phi.^2) ...
        			+ D * alpha_s .* sin(psiI).^2 .* (2 * cos(psiI).^2 - (I4 - 1) ./ alpha_phi.^2);
    dalpha_phi_dsigma = alpha_s .* cos(theta) ./ rhoI - r .* drho_dsigmaI ./ rhoI.^2;
    dF_s_dpsi = 2 * D * sin(psiI) .^3 .* cos(psiI) .* (alpha_s.^3 ./ alpha_phi - alpha_s .* alpha_phi) ...
           	  + 2 * D * (I4 - 1) .* sin(psiI) .* cos(psiI) .* alpha_s ./ alpha_phi;
    dF_s_dalpha_s = C * (1 ./ alpha_phi + 3 ./ (alpha_s.^4 .* alpha_phi.^3)) ...
        		  + D * sin(psiI).^2 .* (2 * alpha_s.^2 .* sin(psiI).^2 + (I4 - 1)) ./ alpha_phi;

    % Now we can form the rhs following the equations of the accompanying
    % manuscript.
    rhs = [alpha_s .* ((sin(theta) ./ r - kappa) .* cos(theta) ./ r - Q ./ (r * EB));...
           (alpha_s .* (kappa .* Q + 2 * zetaI .* cos(theta) .* (F_phi - F_s)) ./ r - 2 * F_s .* dzeta_dsigmaI - 2 * zetaI .* dF_s_dalpha_phi .* dalpha_phi_dsigma - 2 * zetaI .* dF_s_dpsi .* dpsi_dsigmaI) ./ (2 * zetaI .* dF_s_dalpha_s);...
           alpha_s .* cos(theta);...
           alpha_s .* kappa;...
           alpha_s .* (r * IOP - 2 * r .* kappa .* zetaI .* F_s - 2 * sin(theta) .* zetaI .* F_phi)];

end

function res = bvpBC(ya,yb)
% bvpBC Compute the residual of the boundary conditions for the bvp.

% Compute the stretch in the phi direction at the Sigma = epsilon (a).
alpha_phi_a = ya(3) / rho(1);

% Compute the deformation gradient in the s direction at Sigma = epsilon (a).
F_s_a = C * (ya(2) / alpha_phi_a - 1 / (ya(2)^3 * alpha_phi_a^3)) ...
		+ D * (ya(2)^2 * sin(psi(1))^2 + alpha_phi_a^2 * cos(psi(1))^2 - 1) * ya(2) * sin(psi(1))^2 / alpha_phi_a;

% Form the residual, with three conditions on the left and two on the right.
res = [ya(3) - sigma_epsilon * ya(2);
       ya(4) - sigma_epsilon * ya(1) * ya(2);
       cos(ya(4)) * ya(5) - ya(3)^2 * IOP / 2 + 2 * sin(ya(4)) * ya(3) * zeta(1) * F_s_a;
       yb(3) - corneal_r; % Set r at the cornea.
       yb(4) - corneal_theta % Set theta at the cornea.
       ];
end
end